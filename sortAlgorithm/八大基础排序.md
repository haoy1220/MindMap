# 八大基础排序

![排序算法](./images/sort.png)

## 一、冒泡排序

**思路：**

- 俩俩交换比较大小，大的放在后面，第一遍后最大的移到到最后一位；
- 因为俩俩交换，需要n-1趟排序，比如10个元素，需要9趟排序。

**代码实现：**

```java
public class Solution {
    public void bublleSort(int[] nums) {
        //排序n-1趟
        for (int i = 0; i < nums.length - 1; i++) {

            //i趟过后只要n-1-i次排序
            for (int j = 0; j < nums.length - 1 - i; j++) {
                if (nums[j] > nums[j + 1]) {
                    int temp = nums[j];
                    nums[j] = nums[j + 1];
                    nums[j + 1] = temp;
                }
            }
        }
    }
}
```

**优化：**

- 考虑到可能提前排好，使用一个标记记录是否发生交换。

**代码实现：**

```java
public class Solution2 {
    public void bublleSort(int[] nums) {
        //排序n-1趟
        for (int i = 0; i < nums.length - 1; i++) {

            boolean isChange = false;

            //i趟过后只要n-1-i次排序
            for (int j = 0; j < nums.length - 1 - i; j++) {
                if (nums[j] > nums[j + 1]) {
                    int temp = nums[j];
                    nums[j] = nums[j + 1];
                    nums[j + 1] = temp;

                    //发生交换就标记
                    isChange = true;
                }
            }

            //标记为false说明已经排好，可以结束了
            if (!isChange) break;
        }
    }
}
```



## 二、选择排序

**思路：**

- 找到最大的元素，与数组最后一位交换；
- 当只有一个数时，则不需要选择了，因此需要n-1趟排序。

**代码实现：**

```java
public class Solution {
    public void selectSort(int[] nums) {
        //n-1趟排序
        for (int i = 0; i < nums.length - 1; i++) {

            //标记最大值的下标
            int max = 0;

            //每一趟过后少比较一位，即n-i次比较
            for (int j = 0; j < nums.length - i; j++) {
                if (nums[max] < nums[j]) {
                    max = j;
                }
            }

            //如果最大值不是当前最后一位就交换
            if (max != nums.length - 1 - i) {
                int temp = nums[nums.length - 1 - i];
                nums[nums.length - 1 - i] = nums[max];
                nums[max] = temp;
            }
        }
    }
}
```



## 三、插入排序

**思路：**

- 将一个元素插入到有序数组中；
- 因为初始时并不知道数组是否有序，所以将第一个数视为有序数组提供给后续元素插入；
- 因为第一个元素不需要插入，故只需要n-1趟排序。

**代码实现：**

```java
public class Solution {
    public void insertSort(int[] nums) {

        //将第1个数当作有序数组，所以从1开始
        for (int i = 1; i < nums.length; i++) {

            int temp = nums[i];

            //向前比较，并记录位置
            while (i >= 1 && nums[i - 1] > temp) {
                nums[i] = nums[i - 1];
                i--;
            }

            //找到合适的位置了，插入
            nums[i] = temp;
        }
    }
}
```

**优化：**

- 因为循环使用的i和后退使用的i一致，可能会造成不必要的浪费;
- 使用一个临时变量来代替i进行后退记录。

**代码实现：**

```java
public class Solution2 {
    public void insertSort(int[] nums) {

        //将第1个数当作有序数组，所以从1开始
        for (int i = 1; i < nums.length; i++) {

            int temp = nums[i];
            //另起一个变量来进行后退记录
            int tempi = i;

            ////向前比较，并记录位置
            while (tempi >= 1 && nums[tempi - 1] > temp) {
                nums[tempi] = nums[tempi - 1];
                tempi--;
            }

            //找到合适的位置了，插入
            nums[tempi] = temp;
        }
    }
}
```



## 四、快速排序

**思路：**

- 在数组中找一个支点，将比它大的都放到右边，比它小的都放到左边，接着不断对左右两边执行相同的操作；
- 由此我们可以使用递归解决，使用取中切分确定支点；
- 使用{1, 2, 3, 4, 3, 2, 1}这个用例可以解开很多特殊情况的疑惑。

**代码实现：**

```java
public class Solution {
    public void quickSort(int[] nums) {
        if (nums.length == 0) return;
        sort(nums, 0, nums.length - 1);
    }

    public void sort(int[] nums, int begin, int end) {
        int i = begin;
        int j = end;

        //先将中间点当作支点，左边全小于中间点，右边全大于中间点
        int pivot = nums[(begin + end) / 2];

        //左右两端扫描，直到两端交替错开
        while (i <= j) {

            //找到比支点大的i
            while (pivot > nums[i]) {
                i++;
            }

            //找到比支点小的j
            while (pivot < nums[j]) {
                j--;
            }

            //将找到的i、j对应位的值交换，然后继续下一位
            if (i <= j) {
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
                i++;
                j--;
            }
        }

        //左边递归，结束条件就是当只有一个元素的时候
        if (begin < j) {
            sort(nums, begin, j);
        }

        //右边递归，结束条件就是当只有一个元素的时候
        if (end > i) {
            sort(nums, i, end);
        }
    }
}
```



## 五、归并排序

**思路：**

- 将两个排好序的数组合并到一个数组
  - 不断拆分，直到每个数组只包含一个元素；
  - 开始合并（这里合并其实都是合并到原数组，只有拆分的时候才开辟了新的空间）。

**代码实现：**

```java
public class Solution {
    public void mergeSort(int[] nums) {
        if (nums.length == 0) return;
        splitAndMerge(nums, 0, nums.length - 1);
    }

    public void splitAndMerge(int[] nums, int begin, int end) {
        int mid = (begin + end) / 2;

        //将数组不断拆分成左右两个部分
        splitAndMerge(nums, begin, mid);
        splitAndMerge(nums, mid + 1, end);

        //最后合并处理
        merge(nums, begin, mid + 1, end);

    }

    public void merge(int[] nums, int begin, int midAdd1, int end) {
        //定义一个左边的数组
        int[] leftnums = new int[midAdd1 - begin];

        //定义一个右边的数组
        int[] rightnums = new int[end - midAdd1 + 1];

        //填充数据
        for (int i = begin; i < midAdd1; i++) {
            leftnums[i - begin] = nums[i];
        }
        for (int i = midAdd1; i <= end; i++) {
            rightnums[i - midAdd1] = nums[i];
        }

        int i = 0;
        int j = 0;
        int k = begin;

        //比较两个数组的元素大小，小的先填充到原数组中
        while (i < leftnums.length && j < rightnums.length) {
            if (leftnums[i] < rightnums[j]) {
                nums[k] = leftnums[i];
                i++;
                k++;
            } else {
                nums[k] = rightnums[j];
                j++;
                k++;
            }
        }

        //右边的填充完了，将左边的全部填入(已经排好序了)
        while (i < leftnums.length) {
            nums[k] = leftnums[i];
            i++;
            k++;
        }

        //左边的填充完了，将右边的全部填入(已经排好序了)
        while (j < rightnums.length) {
            nums[k] = rightnums[j];
            k++;
            j++;
        }
    }
}
```



## 六、堆排序

**思路：**

**代码实现：**



## 七、希尔排序

**思路：**

**代码实现：**



## 八、基数排序（桶排序）

**思路：**

**代码实现：**



### 稳定性：

**理解：**排序前2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。 

**用处：**只有当在“二次”排序时不想破坏原先次序，稳定性才有意义 。

>  如果我们只对一串数字排序，那么稳定与否确实不重要，因为一串数字的属性是单一的，就是数字值的大小。但是排序的元素往往不只有一个属性，例如我们对一群人按年龄排序，但是人除了年龄属性还有身高体重属性，在年龄相同时如果不想破坏原先身高体重的次序，就必须用稳定排序算法. 



### 总结：

![复杂度](./images/sum.png)



